# DB_Redis

1. Redis는 Memory를 사용하는 저장소입니다. 
아시다시피 Redis는 Memory를 주 저장소로 하고 서비스를 제공합니다. 
다시 말하면, Memory의 용량범위를 벗어나는 데이터는 저장할 수 없습니다. 
Disk와 Memory의 용량대비 비용의 차이는 상당히 크며, 우리가 서비스를 제공하고 벌어들이는 수입에 비해 기하급수적으로 증가하는 데이터 저장소의 하드웨어를 추가하는 노력을 들여야 할 수 있다는 우려는 생각해야 합니다. 
또, AWS에서 각 서버의 메모리를 온라인 상태에서 증설할 수 있는지에 대해서도 검토가 필요할 것입니다. (만약, 온라인 상태 증설이 불가능하다면 증설하는 동안 대체서비스를 돌릴 수 있는 방안도 마련되어야 합니다.)
가장 좋은 것은 적정 수준 이상으로 데이터가 늘어나지 않도록 장치를 마련하는 것입니다. (데이터를 누적하는 것이 아니라 특정 시점에는 삭제되어도 상관없도록 업무가 정의되어야 합니다.)

2. Redis의 기본 저장 방식은 Key - Value 입니다. 
저장 방식이 이러하다 보니 조회도 정확한 Key가 없으면 성능이 상당히 느릴 수 있습니다. (Key가 순차적으로 저장되지 않을 수 있기 때문입니다.)
(주문번호 + 상태)를 주문데이터의 Key로 하여 저장하실 계획이기 때문에, 정확한 값을 조회하기 위해 항상 (주문번호)를 사용하여 찾는다면 해당 범위 내 SCAN이 이루어지게 될 것입니다. 
몇 건 안되는 데이터 내에서 소수의 이터레이션으로 찾을 수 있는 경우 크게 이슈가 없을 수 있으나, 
경우에 따라서는 수십만건에 대한 상태 정보 조회를 실시간으로 계속 요청하는 API를 통해 SCAN이 계속해서 이루어진다면 충분한 성능을 발휘할 수 있을 지 고민해봐야 합니다. 
(API를 통해 주문만 인입되는 것이 아니라 각 주문의 현재 상태정보를 조회하는 요청도 인입될 것이기 때문입니다.)
특정 Block을 SCAN하는 것보다 (주문번호 + 상태)를 여러 개 만들어 조회하는 것이 성능이 더 좋을 수 있습니다. 


3. Redis는 Single Thread 방식으로 동작합니다. 
Single Thread의 특성에 따라 한 번에 하나의 Request만을 수행하고, 모든 Request는 순차적으로 이루어집니다. 
Redis의 처리 성능이 Request의 유입을 커버할 수 있는 수준으로 충분히 빠르다면 상관없지만, 수만 건의 Request가 동시에 들어왔을 때 Redis 서버가 충분히 서비스를 제공할 수 있을지 장담하기 어렵습니다. 
Multi-Master + Multi-Slave 구성을 하든지, N개 Cluster 구성을 하여 부하를 분산시키는 것도 고려해야 하며, 최대한 빠른 성능을 낼 수 있도록 최적의 구성방안을 찾아봐야 할 것으로 생각됩니다. 

4. Queue의 구현 방식으로 Redis Pub/Sub을 고려하신다면 메시지 휘발성에 대해 생각해야 합니다. 
FIFO를 적용하는 수단으로 Redis의 Pub/Sub을 사용하려고 하신다면 Publish된 메시지는 Subscriber가 없는 경우 사라진다는 것을 염두에 두고 개발하셔야 합니다. 
가급적이면 데이터 유실이 발생하면 안되는 업무에서는 Redis를 사용한 Pub/Sub으로 Message Queue를 대신하지 않도록 권고하는 것이 많이 보입니다. 
